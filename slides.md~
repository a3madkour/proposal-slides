---
# try also 'default' to start simple
theme: academic
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# apply any windi css classes to the current slide
class: 'text-center'
# https://sli.dev/custom/highlighters.html
highlighter: shiki
# show line numbers in code blocks
lineNumbers: false
# some information about the slides, markdown enabled
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
# persist drawings in exports and build
drawings:
  persist: false
# page transition
transition: fade
# use UnoCSS
css: unocss
---

# Covering Designers' Bayes-ic Needs: Probabilistic Logic Programming for Content Generation in Games 


<!--
The last comment block of each slide will be treated as slide notes. It will be visible and editable in Presenter Mode along with the slide. [Read more in the docs](https://sli.dev/guide/syntax.html#notes)
-->

---

# Outline

- Motivation
- General Framework
- Completed work
- Planed work
- Timeline

---
layout: cover
---

# Motivation

---

# Why Procedural Content Generation (PCG)?


## Labor 

<v-clicks>

- Reduce (undesirable?) work done by game development and so.... 
- Reduce costs of game dev
- Create value for shareholders 

</v-clicks>

## Artistic 

<v-clicks>

- Generate artifacts which cannot be generated by hand 

- As a tool in game design 

- A means to explore a design space 

- Integrate content generation within core game mechanic

</v-clicks>

<!--
Here is another comment.
-->

---

# Why is PCG not more widespread?

<v-clicks>

- Most work is focused on level generation -- domain restriction
- Defining a good generator is hard -- expertise restriction
- Twice the amount of levels for at least twice the amount of work! Guaranteed!
- Creating interesting content generators requires a large amount of expertise outside of game design

</v-clicks>



---

# Goal

<v-clicks>

- For PCG to be a useful to a designer, there must exist tools that make it more accessible 

- Current techniques have difficulty balancing authorial control with automation

- Domain is often restricted: (just level generation) 

- Or diversity is restricted : (just levels we know work)

- Hard to give insight into what designers want apriori
	
- We want designers involved not in just the use of content generators but in its core development

- Allow for iterative design loops that mesh well with specifying generators


</v-clicks>

---

# Opinion: Randomness is important to PCG

<v-clicks>

- In this work we want a designer to define a generative space not a single artifact
  - For example: A level generator not a single level
- We then want to sample from that space
- This involves a form of randomness
- Randomness is hard to reason about

</v-clicks>
<!--
Presenter note with **bold**, *italic*, and ~~striked~~ text.

Also, HTML elements are valid:
<div class="flex w-full">
  <span style="flex-grow: 1;">Left content</span>
  <span>Right content</span>
</div>
-->


---
class: px-20

---


# What tools do we have to model randomness?

<v-clicks>

- Approach: Leverage existing mathematical formulations of uncertainty to come up with tools that makes reasoning about randomness of generators clearer
- What does Bayesian reasoning make clearer?
- Think of PCG as probability distributions
- You can control the diversity and how you sample in generative space via Bayesian conditioning
- Many existing techniques in AI for modeling with randomness are Bayesian
- Provides an elegant mathematical language for which we can both define our generator and adjust it 

</v-clicks>

---
layout: cover
---

# General Framework

---

# Example: Grid-Based Level Generation

<div v-click>
<p style="color:green; font-size:30px; position: absolute; left:20px; top:105px">Start</p>

<arrow x1="70" y1="150" x2="160" y2="235" color="green" width="3" arrowSize="1" />
</div>

<div v-click>
<arrow x1="450" y1="500" x2="355" y2="425" color="red" width="3" arrowSize="1" />
<p style="color:red; font-size:30px; position: absolute; left:440px; top:490px">End</p>
</div>

<div v-click>
<arrow x1="450" y1="150" x2="355" y2="235" color="black" width="3" arrowSize="1" />
<p style="color:black; font-size:30px; position: absolute; left:400px; top:105px">Un-traversable</p>
</div>


<div style="display:flex; align-items:center; justify-content:space-evenly; height:100%">
<OneGrid grid_num="11" size="95" />
<div v-click>
<p style="font-size:50px"> => </p>
</div>
<div v-click>
<OneGrid grid_num="11" size="95" value="true" />
</div>
</div>


---

# Example: 2x2 Grid

- Let's call the "universe" of all possible grids $\Omega$

<HelloWorld />

---

# Constraints

<v-clicks>

- The way to specify what we want out of $\Omega$ is through constraints
- Eliminate undesirable artifacts
- Weigh artifacts differently depending on design criteria

- In this work we categorize constraints into two categories:
  - Validity Constraints
  - Quality Constraints

</v-clicks>

---

# Validity Constraints

<v-clicks>

- Structured artifacts are artifacts strong constraints that need to be satisfied
- Such constraints cannot be violated for the artifact to be usable
- Let's call the subset of $\Omega$ that are consistent with these constraints $V$
- Levels need a beginning, end and a path from start to end

</v-clicks>


---

# Formal definitions: Valid Generator

Let $\Omega$ be the set of possible artifacts, and $V \subseteq \Omega$ be the set of valid artifacts.
Then a valid generator is a probability distribution P such that for all $\omega \notin V$ $P(\omega) = 0$ 

<div v-click>

<HelloWorld valid="true"/>

</div>


---

# Quality Constraint

<v-clicks>

- We need more than validity
- Not all "valid" artifacts are desirable
- Some constraints are not hard and fast rules
- Notions of quality can be vague
- Multiple notions of quality for a given generator

- Quality Constraints capture non-required criteria
- Constraints that are not needed for an artifact to be usable
- Can be hard logical rules or soft rules that weigh artifacts differently
- Let's call the subset of $\Omega$ that are consistent with these constraints $Q$

- In our example: There must be more than one path

</v-clicks>

---

# Example: Quality Constraint

<HelloWorld valid="true" quality="true"/>

---

# Formal definitions: Quality Generator

Let $Q$ be the set of artifacts consistent with a set of quality constraints, $P(Q)$ be the probability that a generator $P$ generates $Q$, $V$ be a set of valid artifacts that $P$ can generate and $P(V)$ the probability that $P$ generates $V$. Then a quality generator is a valid generator and by Bayes' Rule defined:  
$$ P(V \vert Q) = \frac{P(Q \vert V)P(V)}{P(Q)}$$
where $P(Q \vert V)$ is the probability of generating a quality artifact given it has generated a valid artifact.

<v-clicks>

- In Bayesian statistics we refer to $P(V \vert Q)$ as the posterior, $P(Q \vert V)$ the likelihood, $P(V)$ the prior and $P(Q)$ as the marginal.
- Thus, the quality generator is the posterior and the valid generator is the prior. The likelihood captures how likely the generator is to generate quality artifacts given that it has generated a set of valid artifacts $V$.


</v-clicks>

---

# Hard and soft constraints
<v-clicks>

- In the optimization literature there already exists a distinction between *hard* and *soft* constraints
  - Hard constraints: Constraints that restrict the solution space, i.e. they *have* be satisfied 
  - Soft constraints: Constraints that are optional but preferred, i.e. they *ought* to be satisfied but don't have to be.
- Solutions are eliminated by using hard constraints and penalized using soft constraints

</v-clicks>

---

# Why the distinction between validity/quality and hard/soft?

<v-clicks>

- Validity constraints are hard constraints
  - They need to eliminate non-playable level for example
- Quality constraints can be hard constraints or soft constraints
  - They can be an arbitrary combination of both
- We make this distinction for following reasons
  - Separate concerns of validity and quality
  - Allow for generators to have multiple sets of quality constraints under the same validity constraints
- Ultimately a terminology convention, one can make the formulation using hard and soft constraints
  - Whereby hard quality constraints are folded into validity constraints

</v-clicks>

---

# Great but why?


- In the Bayesian setting we often formulate our models in the form 
$$P(\theta \vert X) = \frac{P(X \vert \theta)P(\theta)}{P(X)}$$
where X is the data and $\theta$ are model parameters. 

<v-clicks>

- PCGML approaches are not always Bayesian and do not guarantee the $P(\theta)$ is *valid*
- PCGML that are non-Bayesian maximize the likelihood $P(X \vert \theta)$ without any guarantees
- For example: do not guarantee playable levels

- In declarative and constructive PCG approaches the prior and the likelihood are given implicitly

- This formulation is useful in both understanding and specifying the randomness of PCG


</v-clicks>

---

# The generation process

<v-clicks>

- Looking at the quality generator
$$ P(V \vert Q) = \frac{P(Q \vert V)P(V)}{P(Q)}$$

- We can view specifying prior $P(V)$ as the way to ensure strong constraints that must hold (i.e. validity)
- We can view specifying the likelihood as altering that distribution towards designer preferences. 
- The questions now is: how do we provide designer-facing tools for specifying the prior and the likelihood?

</v-clicks>


---
layout: cover
---

# Completed Work

---

# For now assume the prior

<v-clicks>

- There are many existing generative techniques that enforce constraints
  - I.e. specify the prior $P(V)$ 
- They are hard to control
- Hard to prevent uninteresting or repetitive content
  - Most commonly constructive or template techniques
- One such technique that has found use in both industry and academia is grammars

</v-clicks>

---

# Generative Grammars

<v-clicks>

- Re-writing systems
- Used in many commercial systems like "Speed tree" and "City Engine"
- Often very domain specific
- What does this give us?

</v-clicks>
<v-click>
 <img src="imgs/grammar.png" class="absolute w-150" /> 

</v-click>
 
----
# Grammar


  
<iframe src="https://a3madkour.github.io/graph-deploy/" height="80%" width="100%"> </iframe>

<p style='font-size:6.5pt'>
    Abdelrahman Madkour, Stacy Marsella, and Casper Harteveld. 2022. Towards Non-Technical Designer Control over PCG Systems: Investigating an Example-Based Mechanism for Controlling Graph Grammars. In Proceedings of the 17th International Conference on the Foundations of Digital Games (FDG '22). Association for Computing Machinery, New York, NY, USA, Article 39, 1–12. https://doi.org/10.1145/3555858.3555895
</p>

----

# Designer control over the generative space of the grammar

 - Explored two ways of specifying the likelihood: 
   - Examples:
	 - Designers select a space of example they wish to move the generative space towards
   - Recipes
	 - Designers adjust application of grammar rules by hand

---

# Example-based: Learning

Example based mechanism allows designers to specify $P(Q \vert V)$
<div v-clicks>

 - Select examples that are relevant to metrics of interest
 - Assumes a multinomial distribution over the rules where the inital parameters are uniform
 - Generator learns the maximum likelihood of the rules' parameters given the selected examples
</div>
 


---

# Examples app

<p style='font-size:6.5pt'>
    Abdelrahman Madkour, Stacy Marsella, and Casper Harteveld. 2022. Towards Non-Technical Designer Control over PCG Systems: Investigating an Example-Based Mechanism for Controlling Graph Grammars. In Proceedings of the 17th International Conference on the Foundations of Digital Games (FDG '22). Association for Computing Machinery, New York, NY, USA, Article 39, 1–12. https://doi.org/10.1145/3555858.3555895
</p>


<iframe src="https://fdgsubmission.github.io/examples_app/" style="transform:scale(0.5,0.5);transform-origin:top left;" height="900px" width="2000px"> </iframe>



---

# Recipes app

<p style='font-size:6.5pt'>
    Abdelrahman Madkour, Stacy Marsella, and Casper Harteveld. 2022. Towards Non-Technical Designer Control over PCG Systems: Investigating an Example-Based Mechanism for Controlling Graph Grammars. In Proceedings of the 17th International Conference on the Foundations of Digital Games (FDG '22). Association for Computing Machinery, New York, NY, USA, Article 39, 1–12. https://doi.org/10.1145/3555858.3555895
</p>


<iframe src="https://fdgsubmission.github.io/recipes_app/" style="transform:scale(0.5,0.5);transform-origin:top left;" height="900px" width="1800px"> </iframe>



----

# Study: Preferences Results

<p style='font-size:6.5pt'>
    Abdelrahman Madkour, Stacy Marsella, and Casper Harteveld. 2022. Towards Non-Technical Designer Control over PCG Systems: Investigating an Example-Based Mechanism for Controlling Graph Grammars. In Proceedings of the 17th International Conference on the Foundations of Digital Games (FDG '22). Association for Computing Machinery, New York, NY, USA, Article 39, 1–12. https://doi.org/10.1145/3555858.3555895
</p>


<Plots />


---

# Limitations

<v-clicks>

- Study was limited: only student game designers and in a classroom context
- The learning mechanism in example-based approach is limited 
  - Designers can't move the generative space towards the metrics as much as they want
  - Need a more expressive language to learn the desired space
- Metrics are spherical cows -- (too idealized for the real world)
  - Nevertheless it proved a more effective means of controlling the randomness; targeting desired areas in the design space.

- Approach requires that a prior is given
  - Need an designer-accessible way to specify the prior 

</v-clicks>

---
layout: cover
---

# Planed Work

---


# Defining the prior $P(V)$

<v-clicks>

- Learn it!
  - Well, can't really guarantee play-ability

- Gimme it!
  - In game's research the more general approach of doing so is via declarative programming 
	
</v-clicks>

---

# Answer Set Programming

 <img src="imgs/asp.png" class="relative w-110 left-20%" /> 

Smith, A. M., & Mateas, M. (2011). Answer set programming for procedural content generation: A design space approach. IEEE Transactions on Computational Intelligence and AI in Games, 3(3), 187-200.

---


# Answer Set Programming

<v-clicks>

- Elegant general way for specifying valid design space
  - In our formulation this is the prior
- Has very nice features that allow for interaction with generative space
- No way of explicitly controlling randomness 
- Diversity is harder to control -- implementation specific

</v-clicks>


---

# Probabilistic Logic Programming (PLP)


<v-clicks>

- Probabilistic Logic Semantics give explicit formulation of randomness
- Semantics are defines as a distribution over possible worlds/initiations of logical variables.
- Makes diversity easier to reason about
- Defining the prior is explicitly probabilistic
- Allows for easy integration of multiple ways of specifying the likelihood including the method mentioned earlier

</v-clicks>

---

# Current PLP Systems: Problog

<v-clicks>

- Most mature ecosystem, Problog, supports
- Prolog-like syntax -- also declarative
- Learning parameters from data   
- Answering probabilistic queries exactly and approximately,
- Compiling program down an efficient data-structure from which sampling is linear in size of data-structure.

</v-clicks>

---

# More Prob-log More Prob-lems

<v-clicks>

- Problog has limitations as language for PCG
- Strong negation is not handled 
- Specifying validity constraints becomes much more difficult 
- Hard to specify the prior $P(V)$
- No debugging tools
- Well-formedness checking is lacking

</v-clicks>

---

# Thesis Plan
 
<v-clicks>

- Address Problog's lack of strong negation 
- Implement useful quality of life features for designers
- Do a systematic PL and HCI study on both developing and assessing a language for this niche (using PLIERS for example)

</v-clicks>

<v-click>
<p style='font-size:6.5pt'>
    Michael Coblenz, Gauri Kambhatla, Paulette Koronkevich, Jenna L. Wise, Celeste Barnaby, Joshua Sunshine, Jonathan Aldrich, and Brad A. Myers. 2021. PLIERS: A Process that Integrates User-Centered Methods into Programming Language Design. ACM Trans. Comput.-Hum. Interact. 28, 4, Article 28 (August 2021), 53 pages. https://doi.org/10.1145/3452379
</p>

</v-click>

---

# Study: Preliminary Design 

We will base our approach to testing and implementing our language design changes using the PLIERS framework
 
 
 <div style="display:flex; align-content:center; justify-content:center">
 <img src="imgs/PLIERS.png" class="w-70 content-center" /> 
 </div>

<p style='font-size:6.5pt'>
    Michael Coblenz, Gauri Kambhatla, Paulette Koronkevich, Jenna L. Wise, Celeste Barnaby, Joshua Sunshine, Jonathan Aldrich, and Brad A. Myers. 2021. PLIERS: A Process that Integrates User-Centered Methods into Programming Language Design. ACM Trans. Comput.-Hum. Interact. 28, 4, Article 28 (August 2021), 53 pages. https://doi.org/10.1145/3452379
</p>


---

# Timeline 
 
<v-clicks>

- May 2023: Submission of preliminary work on Problog at the AIIDE 2023
- August 2023: Recruitment for first user study and pilot testing  
- September 2023: First user study for language usability and identifying needed features (Need finding)
- October 2023: Implementation of negation and other new language features for game design (Design Conception)
- December 2023: Second study with a few PCG practioners (Risk analysis)
- Jan 2024: IJCAI submission on the new language features we introduce
- February 2024: CHI Play submission of the results of the second user study
- March 2024: Second round of major implemention changes (Design Refinement)
- May 2024: Third user study with introduced language features (Assessment)
- June 2024: Thesis Defense 
- September 2024: CHI submission for final assessment on user studies on probabilistic programming languages in games

</v-clicks>

